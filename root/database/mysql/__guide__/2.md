> 微信本地的聊天记录的存储就是用的 SQLite

## 存储引擎

#### 存储引擎相关的命令

- 查看 MySQL 提供的所有存储引擎

  ```sql
  SHOW ENGINES;
  ```

- 查看 MySQL 当前默认的存储引擎

  ```sql
  SHOW VARIABLES LIKE '%storage_engine%';
  ```

- 查看表的存储引擎

  ```sql
  SHOW TABLE STATUS LIKE 'table_name';
  ```

#### MyISAM 和 InnoDB 的区别

|                                    | MyISAM     | InnoDB                                                                                                                |
| ---------------------------------- | ---------- | --------------------------------------------------------------------------------------------------------------------- |
| 是否支持行级锁                     | 只有表级锁 | 默认行级锁                                                                                                            |
| 是否支持事务                       | 不支持     | 支持                                                                                                                  |
| 是否支持外键                       | 不支持     | 支持                                                                                                                  |
| 是否支持数据库异常崩溃后的安全恢复 | 不支持     | 使用 InnoDB 的数据库再异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` |
| 是否支持 MVCC                      | 不支持     | MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能                                                       |
|                                    |            |                                                                                                                       |
|                                    |            |                                                                                                                       |

> - MySQL InnoDB 引擎通过 `redo log` 保证事务的**持久性**，使用 `undo log` 来保证事务的**原子性**
> - MySQL InnoDB 引擎通过**锁机制**、**MVCC** 等手段来保证事务的隔离性（默认支持的隔离级别是 `REPEATABLE-READ`）
> - 保证了事务的**持久性**、**原子性**、**隔离性**之后，**一致性**才能得到保障

## 锁机制与 InnoDB 算法

#### 表级锁和行级锁对比

|        |                                                                                                                                                              |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 表级锁 | MySQL 中锁定粒度最大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突额概率最高，并发度最低     |
| 行级锁 | MySQL 中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁 |

#### InnoDB 存储引擎的锁算法

- Record Lock：记录锁，单个行记录上大的锁
- Gap Lock：间隙锁，锁定一个范围，不包括记录本身
- Next-Key Lock：临键锁，锁定一个范围，包含记录本身

## 查询缓存

> 执行查询语句的时候，会先查询缓存。<font color="red">不过，MySQL 8.0 版本后移除，因为这个功能不太实用</font>

#### 开启

- `my.cnf` 加入以下配置，重启 MySQL 开启查询缓存

  ```bash
  query_cache_type=1
  query_cache_size=600000
  ```

- MySQL 执行以下命令也可以开启查询缓存

  ```sql
  SET GLOBAL query_cache_type=1;
  SET GLOBAL query_cache_size=600000;
  ```

- 通过 `sql_cache` 和 `sql_no_cache` 来控制某个语句是否需要缓存

  ```sql
  SELECT sql_no_cache COUNT(*) FROM user;
  ```

#### 查询缓存不命中的情况

- 任何两个查询在任何字符上的不同都会导致缓存不命中
- 如果查询中包含任何用户自定义函数、存储过程、环境变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存
- 缓存建立之后，MySQL 的查询缓存系统系统会跟踪查询中涉及的每张表，如果这些表发生变化，那么和这张表相关的所有缓存数据都将失效

## 事务

> 事务是逻辑上的一组操作，要么都执行，要么都不执行

#### 数据库事务

- 开启事务

  ```sql
  START TRANSACTION;
  # 多条 SQL 语句
  COMMIT;
  ```

#### 何为 ACID 特性

|                       |                                                                                              |
| --------------------- | -------------------------------------------------------------------------------------------- |
| 原子性（Actomicity）  | 事务是最小的执行单位，不允许分隔。事务的原子性确保动作要么全部完成，要么完全不起作用         |
| 一致性（Consistency） | 执行事务前后，数据保持一致                                                                   |
| 隔离性（Isolation）   | 并发访问数据库时，一个用户的事务不被其它事务所干扰，各并发事务之间数据库是独立的；           |
| 持久性（Durability）  | 一个事务被提交之后，它对数据库中数据额改变是持久的，即使数据库发生故障也不应该对其有任何影响 |

#### 数据事务的实现原理

- MySQL InnoDB 引擎
  - MySQL InnoDB 引擎通过使用 `redo log` 保证事务的持久性，使用 `undo log` 来保证事务的原子性
  - MySQL InnoDB 引擎通过锁机制、MVCC 等手段来保证事务的隔离性（默认支持的隔离级别是 `REPEATABLE-READ`）
  - 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障

#### 并发事务带来哪些问题
